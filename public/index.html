<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Net Sentinel - Network Monitor</title>
    <!-- Monaco Editor -->
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"></script>
    <!-- Pseudo-Code Language Server (load after Monaco) -->
    <script src="/api/code-server.js" defer></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0f172a;
            color: #e2e8f0;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #1e293b;
        }

        h1 {
            color: #60a5fa;
            margin-bottom: 10px;
            font-size: 2.5rem;
        }

        .version {
            color: #94a3b8;
            font-size: 0.9rem;
        }

        /* Tab Navigation */
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
            border-bottom: 2px solid #1e293b;
        }

        .tab-button {
            background: transparent;
            color: #94a3b8;
            border: none;
            padding: 12px 24px;
            font-size: 1rem;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
            font-weight: 500;
        }

        .tab-button:hover {
            color: #60a5fa;
            background: rgba(96, 165, 250, 0.1);
        }

        .tab-button.active {
            color: #60a5fa;
            border-bottom-color: #60a5fa;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .section {
            background: #1e293b;
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid #334155;
        }

        .section h2 {
            color: #60a5fa;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #cbd5e1;
            font-weight: 500;
        }

        input[type="text"],
        input[type="number"],
        select {
            width: 100%;
            padding: 12px;
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 6px;
            color: #e2e8f0;
            font-size: 1rem;
            transition: border-color 0.2s;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #60a5fa;
        }

        button {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
        }

        button:hover {
            background: #2563eb;
        }

        button:active {
            background: #1d4ed8;
        }

        button:disabled {
            background: #475569;
            color: #94a3b8;
            cursor: not-allowed;
            opacity: 0.6;
        }

        button:disabled:hover {
            background: #475569;
        }

        button.delete {
            background: #ef4444;
            padding: 8px 16px;
            font-size: 0.9rem;
        }

        button.delete:hover {
            background: #dc2626;
        }

        button.delete:disabled {
            background: #475569;
            color: #94a3b8;
        }

        button.delete:disabled:hover {
            background: #475569;
        }

        button.edit {
            background: #f59e0b;
            padding: 8px 16px;
            font-size: 0.9rem;
        }

        button.edit:hover {
            background: #d97706;
        }

        button.edit:disabled {
            background: #475569;
            color: #94a3b8;
        }

        button.edit:disabled:hover {
            background: #475569;
        }

        button.test {
            background: #10b981;
            padding: 8px 16px;
            font-size: 0.9rem;
        }

        button.test:hover {
            background: #059669;
        }

        button.test:disabled {
            background: #475569;
            color: #94a3b8;
        }

        button.test:disabled:hover {
            background: #475569;
        }

        .isp-list,
        .website-list,
        .gameserver-list {
            margin-top: 20px;
        }

        .isp-item,
        .website-item,
        .gameserver-item {
            background: #0f172a;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #334155;
        }

        .item-info {
            flex: 1;
        }

        .item-name {
            font-weight: 600;
            color: #60a5fa;
            margin-bottom: 5px;
        }

        .item-details {
            color: #94a3b8;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .item-actions {
            display: flex;
            gap: 8px;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #64748b;
        }

        .error {
            background: #7f1d1d;
            color: #fca5a5;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            border: 1px solid #991b1b;
        }

        .success {
            background: #14532d;
            color: #86efac;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            border: 1px solid #166534;
        }

        /* Editor Section */
        .editor-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 1200px) {
            .editor-grid {
                grid-template-columns: 1fr;
            }
        }

        .editor-panel {
            display: flex;
            flex-direction: column;
        }

        .editor-panel label {
            font-size: 0.85rem;
            color: #94a3b8;
            margin-bottom: 4px;
        }

        .editor-panel input,
        .editor-panel select {
            margin-bottom: 12px;
        }

        /* Monaco Editor */
        #monaco-editor-container {
            height: 500px;
            border: 1px solid #334155;
            border-radius: 6px;
            margin-bottom: 12px;
        }

        .editor-actions {
            display: flex;
            gap: 12px;
            margin-top: 12px;
        }

        .editor-actions button {
            flex: 1;
        }

        .pseudo-output {
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 18px;
            min-height: 500px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
        }

        .pseudo-output pre {
            background: #020617;
            border-radius: 6px;
            padding: 12px;
            font-size: 0.85rem;
            line-height: 1.4;
            overflow-x: auto;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', monospace;
        }

        .pseudo-output .parsed-table {
            display: table;
            width: 100%;
            border-collapse: collapse;
            margin-top: 8px;
        }

        .parsed-table thead {
            background: #1e293b;
        }

        .parsed-table th {
            text-align: left;
            padding: 10px;
            color: #cbd5e1;
            font-size: 0.85rem;
            font-weight: 600;
            border-bottom: 2px solid #334155;
        }

        .parsed-table tbody tr {
            border-bottom: 1px solid #334155;
        }

        .parsed-table tbody tr:hover {
            background: #0f172a;
        }

        .parsed-table td {
            padding: 10px;
            color: #e2e8f0;
            font-size: 0.875rem;
        }

        .parsed-table td:first-child {
            color: #cbd5e1;
            font-weight: 500;
            width: 30%;
        }

        .editor-subtitle {
            color: #94a3b8;
            font-size: 0.9rem;
            margin-bottom: 8px;
        }

        .log-panel {
            background: #020617;
            border-radius: 6px;
            border: 1px solid #334155;
            padding: 10px;
            max-height: 220px;
            overflow-y: auto;
        }

        .log-entry {
            font-size: 0.8rem;
            line-height: 1.4;
            margin-bottom: 6px;
            color: #cbd5e1;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', monospace;
        }

        .log-entry.error {
            color: #fca5a5;
        }

        .log-entry.success {
            color: #86efac;
        }

        .output-labels {
            margin-top: 12px;
            padding: 10px;
            border: 1px dashed #475569;
            border-radius: 6px;
            background: #031129;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', monospace;
            font-size: 0.85rem;
            color: #cbd5e1;
            max-height: 160px;
            overflow-y: auto;
        }

        .output-section {
            margin-top: 12px;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .modal-content h3 {
            color: #60a5fa;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .modal-content p {
            color: #cbd5e1;
            margin-bottom: 20px;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .modal-actions button {
            min-width: 100px;
        }

        .modal-actions button.cancel {
            background: #475569;
        }

        .modal-actions button.cancel:hover {
            background: #64748b;
        }


        .gameserver-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        .gameserver-details span {
            color: #94a3b8;
        }

        .gameserver-details strong {
            color: #cbd5e1;
        }

        /* Fullscreen Editor Styles */
        .fullscreen-btn {
            background: transparent;
            border: 1px solid #334155;
            color: #94a3b8;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .fullscreen-btn:hover {
            background: rgba(96, 165, 250, 0.1);
            border-color: #60a5fa;
            color: #60a5fa;
        }

        .fullscreen-editor-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #0f172a;
            z-index: 9999;
            flex-direction: column;
        }

        .fullscreen-editor-overlay.active {
            display: flex;
        }

        .fullscreen-navbar {
            background: #1e293b;
            border-bottom: 1px solid #334155;
            padding: 12px 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .fullscreen-navbar .form-group {
            margin-bottom: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .fullscreen-navbar label {
            margin-bottom: 0;
            font-size: 0.85rem;
            color: #cbd5e1;
            white-space: nowrap;
        }

        .fullscreen-navbar input,
        .fullscreen-navbar select {
            padding: 6px 10px;
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 4px;
            color: #e2e8f0;
            font-size: 0.9rem;
            min-width: 120px;
        }

        .fullscreen-editor-container {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
            min-height: 0;
        }

        .fullscreen-editor-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            min-width: 0;
        }

        .fullscreen-monaco-container {
            flex: 1;
            border: none;
            border-radius: 0;
            min-height: 0;
        }

        .fullscreen-output-panel {
            width: 400px;
            background: #1e293b;
            border-left: 1px solid #334155;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .fullscreen-output-content {
            flex: 1;
            padding: 20px;
        }

        .fullscreen-actions {
            padding: 12px 20px;
            background: #1e293b;
            border-top: 1px solid #334155;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .fullscreen-actions button {
            padding: 8px 16px;
            font-size: 0.9rem;
        }

        /* Variable/Parsed Value Display */
        .var-parse-item {
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .var-parse-name {
            font-weight: 600;
            color: #60a5fa;
            font-size: 0.95rem;
            margin-bottom: 8px;
        }

        .var-parse-data {
            color: #cbd5e1;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', monospace;
            font-size: 0.85rem;
            word-break: break-all;
            margin-bottom: 8px;
        }

        .var-parse-add {
            background: transparent;
            border: 1px dashed #475569;
            color: #94a3b8;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
            width: 100%;
        }

        .var-parse-add:hover {
            background: rgba(96, 165, 250, 0.1);
            border-color: #60a5fa;
            color: #60a5fa;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Net Sentinel</h1>
            <div class="version">Version: {{VERSION}}</div>
        </header>

        <!-- Tab Navigation -->
        <div class="tabs">
            <button class="tab-button active" data-tab="isp-website">ISP/Website</button>
            <button class="tab-button" data-tab="protocol">Protocol-Agnostic</button>
        </div>

        <!-- ISP/Website Tab -->
        <div id="isp-website-tab" class="tab-content active">
            <!-- ISP Section -->
            <div class="section">
                <h2>Add ISP</h2>
                <div id="message"></div>
                <form id="isp-form">
                    <div class="form-group">
                        <label for="isp-name">ISP Name</label>
                        <input type="text" id="isp-name" name="name" placeholder="e.g., Google DNS, Cloudflare DNS" required>
                    </div>
                    <div class="form-group">
                        <label for="isp-ip">IP Address</label>
                        <input type="text" id="isp-ip" name="ip" placeholder="e.g., 8.8.8.8, 1.1.1.1" required>
                    </div>
                    <button type="submit">Add ISP</button>
                </form>
            </div>

            <div class="section">
                <h2>ISP List</h2>
                <div id="isp-list" class="isp-list">
                    <div class="empty-state">Loading...</div>
                </div>
            </div>

            <!-- Website Section -->
            <div class="section">
                <h2>Add Website</h2>
                <div id="website-message"></div>
                <form id="website-form">
                    <div class="form-group">
                        <label for="website-url">URL</label>
                        <input type="text" id="website-url" name="url" placeholder="e.g., example.com, https://example.com" required>
                    </div>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="website-direct-connect" name="direct_connect">
                            Enable Direct Connect
                        </label>
                    </div>
                    <div class="form-group" id="direct-url-group" style="display: none;">
                        <label for="website-direct-url">Direct Connect URL (optional)</label>
                        <input type="text" id="website-direct-url" name="direct_connect_url" placeholder="e.g., http://192.168.1.1">
                        <small style="color: #94a3b8; font-size: 0.85rem;">If provided, this URL will be used for direct connection instead of resolving DNS.</small>
                    </div>
                    <button type="submit">Add Website</button>
                </form>
            </div>

            <div class="section">
                <h2>Website List</h2>
                <div id="website-list" class="website-list">
                    <div class="empty-state">Loading...</div>
                </div>
            </div>

            <!-- Game Servers List -->
            <div class="section">
                <h2>Game Servers</h2>
                <div id="gameserver-list" class="gameserver-list">
                    <div class="empty-state">Loading...</div>
                </div>
            </div>
        </div>

        <!-- Protocol-Agnostic Tab -->
        <div id="protocol-tab" class="tab-content">
            <div class="section">
                <h2>Protocol-Agnostic Pseudo-code Editor</h2>
                <p class="editor-subtitle">Write and test pseudo-code in a full-featured editor.</p>
                <div class="editor-grid">
                    <div class="editor-panel">
                        <div class="form-group">
                            <label for="protocol-editor-name">Server Name (for testing)</label>
                            <input type="text" id="protocol-editor-name" placeholder="Test Server">
                        </div>
                        <div class="form-group">
                            <label for="protocol-editor-address">Address</label>
                            <input type="text" id="protocol-editor-address" placeholder="example.com">
                        </div>
                        <div class="form-group">
                            <label for="protocol-editor-port">Port</label>
                            <input type="number" id="protocol-editor-port" placeholder="25565" min="1" max="65535">
                        </div>
                        <div class="form-group">
                            <label for="protocol-editor-protocol">Protocol</label>
                            <select id="protocol-editor-protocol">
                                <option value="UDP">UDP</option>
                                <option value="TCP">TCP</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="protocol-editor-timeout">Timeout (ms)</label>
                            <input type="number" id="protocol-editor-timeout" placeholder="5000" min="1000" value="5000">
                        </div>
                        <div class="form-group">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                            <label for="protocol-editor-code">Pseudo-code</label>
                                <button type="button" id="fullscreen-toggle" class="fullscreen-btn" title="Toggle Fullscreen">
                                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M2 2h4v2H4v2H2V2zm8 0h4v4h-2V4h-2V2zM2 12v-2h2v2h2v2H2v-2zm12 0v2h-4v-2h2v-2h2v2z" fill="currentColor"/>
                                    </svg>
                                </button>
                            </div>
                            <div id="monaco-editor-container"></div>
                        </div>
                        <div class="editor-actions">
                            <button type="button" id="protocol-editor-test">Test</button>
                            <button type="button" id="protocol-editor-save" disabled>Save</button>
                            <button type="button" id="protocol-editor-clear">Clear</button>
                        </div>
                    </div>
                    <div class="pseudo-output" id="protocol-editor-output">
                        <p class="editor-status" id="protocol-editor-status">Status: Ready to test your script</p>
                        <pre id="protocol-editor-raw" style="max-height: 300px; overflow-y: auto;">Raw Response will appear here after preview</pre>
                        <div>
                            <p class="editor-subtitle">Variables</p>
                            <div id="protocol-editor-variables">
                                <div class="var-parse-item">
                                    <div class="var-parse-name">No variables</div>
                                    <div class="var-parse-data">Variables from CODE blocks will appear here</div>
                                </div>
                            </div>
                        </div>
                        <div>
                            <p class="editor-subtitle">Parsed Values</p>
                            <div id="protocol-editor-parsed">
                                <div class="var-parse-item">
                                    <div class="var-parse-name">No parsed values</div>
                                    <div class="var-parse-data">Parsed values will appear here</div>
                                </div>
                            </div>
                        </div>
                        <p class="editor-subtitle" id="protocol-editor-response-time">Response Time: --</p>
                        <div class="output-section">
                            <p class="editor-subtitle">Output Success</p>
                            <div class="output-labels" id="protocol-editor-output-success">
                                Output labels will appear here once the test finishes.
                            </div>
                        </div>
                        <div class="output-section">
                            <p class="editor-subtitle">Output Error</p>
                            <div class="output-labels" id="protocol-editor-output-error">
                                Error labels will appear here if the test fails.
                            </div>
                        </div>
                        <div class="log-panel" id="protocol-editor-log">
                            <div class="log-entry">Logs will appear here when a test runs.</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Fullscreen Editor Overlay -->
    <div id="fullscreen-editor-overlay" class="fullscreen-editor-overlay">
        <div class="fullscreen-navbar">
            <div class="form-group">
                <label for="fullscreen-editor-name">Name:</label>
                <input type="text" id="fullscreen-editor-name" placeholder="Test Server">
            </div>
            <div class="form-group">
                <label for="fullscreen-editor-address">Address:</label>
                <input type="text" id="fullscreen-editor-address" placeholder="example.com">
            </div>
            <div class="form-group">
                <label for="fullscreen-editor-port">Port:</label>
                <input type="number" id="fullscreen-editor-port" placeholder="25565" min="1" max="65535">
            </div>
            <div class="form-group">
                <label for="fullscreen-editor-protocol">Protocol:</label>
                <select id="fullscreen-editor-protocol">
                    <option value="UDP">UDP</option>
                    <option value="TCP">TCP</option>
                </select>
            </div>
            <div class="form-group">
                <label for="fullscreen-editor-timeout">Timeout (ms):</label>
                <input type="number" id="fullscreen-editor-timeout" placeholder="5000" min="1000" value="5000">
            </div>
        </div>
        <div class="fullscreen-editor-container">
            <div class="fullscreen-editor-main">
                <div id="fullscreen-monaco-container" class="fullscreen-monaco-container"></div>
                <div class="fullscreen-actions">
                    <button type="button" id="fullscreen-editor-test">Test</button>
                    <button type="button" id="fullscreen-editor-save" disabled>Save</button>
                    <button type="button" id="fullscreen-editor-clear">Clear</button>
                    <button type="button" id="fullscreen-editor-close" class="delete">Exit Fullscreen</button>
                </div>
            </div>
            <div id="fullscreen-output-panel" class="fullscreen-output-panel">
                <div class="fullscreen-output-content" id="fullscreen-output-content">
                    <!-- Output content will be moved here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="delete-modal" class="modal">
        <div class="modal-content">
            <h3>Confirm Delete</h3>
            <p id="delete-modal-message">Are you sure you want to delete this item?</p>
            <div class="modal-actions">
                <button class="cancel" id="delete-modal-cancel">Cancel</button>
                <button class="delete" id="delete-modal-confirm">Delete</button>
            </div>
        </div>
    </div>

    <script>
        const VERSION = '{{VERSION}}';

        // Monaco Editor instance
        let monacoEditor = null;
        let fullscreenEditor = null;
        let isFullscreen = false;
        let isTestRunning = false;
        
        // Track initial state for Save button enable/disable (regular editor)
        let initialCode = '';
        let initialFormData = {
            name: '',
            address: '',
            port: '',
            protocol: '',
            timeout: ''
        };
        
        // Track initial state for fullscreen editor
        let initialFullscreenCode = '';
        let initialFullscreenFormData = {
            name: '',
            address: '',
            port: '',
            protocol: '',
            timeout: ''
        };

        // Initialize Monaco Editor
        require.config({ paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs' } });
        require(['vs/editor/editor.main'], function () {
            // Wait for language server to be loaded (it loads asynchronously)
            function initEditor() {
                // If editor already exists, don't initialize again
                if (monacoEditor) {
                    return;
                }
                
                if (typeof window.pseudoCodeLanguageServerLoaded !== 'undefined' && window.pseudoCodeLanguageServerLoaded) {
                    createEditor();
                } else {
                    // Wait for language server to load
                    let editorCreated = false;
                    const createEditorOnce = () => {
                        if (!editorCreated) {
                            editorCreated = true;
                            createEditor();
                        }
                    };
                    window.addEventListener('pseudoCodeLanguageServerReady', createEditorOnce, { once: true });
                    // Fallback timeout - if language server doesn't load in 2 seconds, proceed anyway
                    setTimeout(createEditorOnce, 2000);
                }
            }
            
            function createEditor() {
                // Prevent creating duplicate editors
                if (monacoEditor) {
                    return;
                }
                
                monacoEditor = monaco.editor.create(document.getElementById('monaco-editor-container'), {
                    value: `# Minecraft-style query
PACKET_START
WRITE_BYTE 0xFE
WRITE_BYTE 0xFD
WRITE_BYTE 0x09
WRITE_INT 0x00000000
PACKET_END

RESPONSE_START
EXPECT_BYTE 0xFE
EXPECT_BYTE 0xFD
READ_BYTE packet_type
READ_STRING_NULL session_id
READ_STRING_NULL challenge_token
RESPONSE_END`,
                    language: 'pseudo-code',
                    theme: 'pseudo-code-theme',
                    automaticLayout: true,
                    fontSize: 14,
                    minimap: { enabled: true },
                    wordWrap: 'on',
                    lineNumbers: 'on',
                    scrollBeyondLastLine: false,
                    suggestOnTriggerCharacters: true,
                    quickSuggestions: {
                        other: true,
                        comments: false,
                        strings: false
                    },
                    parameterHints: {
                        enabled: true
                    },
                });
                
                // Initialize initial state tracking
                initialCode = monacoEditor.getValue();
                initialFormData = {
                    name: document.getElementById('protocol-editor-name').value,
                    address: document.getElementById('protocol-editor-address').value,
                    port: document.getElementById('protocol-editor-port').value,
                    protocol: document.getElementById('protocol-editor-protocol').value,
                    timeout: document.getElementById('protocol-editor-timeout').value
                };
                
                // Add change listeners
                setupChangeTracking();
            }
            
            initEditor();
            
            // Initialize fullscreen editor (hidden initially)
            createFullscreenEditor();
        });

        // Fullscreen Editor Functions
        function createFullscreenEditor() {
            // Wait for Monaco to be available
            if (typeof monaco === 'undefined' || !monaco.editor) {
                setTimeout(createFullscreenEditor, 100);
                return;
            }
            
            const container = document.getElementById('fullscreen-monaco-container');
            if (container && !fullscreenEditor) {
                fullscreenEditor = monaco.editor.create(container, {
                    value: '',
                    language: 'pseudo-code',
                    theme: 'pseudo-code-theme',
                    automaticLayout: true,
                    fontSize: 14,
                    minimap: { enabled: true },
                    wordWrap: 'on',
                    lineNumbers: 'on',
                    scrollBeyondLastLine: false,
                    suggestOnTriggerCharacters: true,
                    quickSuggestions: {
                        other: true,
                        comments: false,
                        strings: false
                    },
                    parameterHints: {
                        enabled: true
                    },
                });
            }
        }
        
        function setupChangeTracking() {
            // Track code changes
            if (monacoEditor) {
                monacoEditor.onDidChangeModelContent(() => {
                    checkForChanges();
                });
            }
            
            // Track form field changes
            const fields = ['protocol-editor-name', 'protocol-editor-address', 'protocol-editor-port', 'protocol-editor-protocol', 'protocol-editor-timeout'];
            fields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) {
                    field.addEventListener('input', checkForChanges);
                    field.addEventListener('change', checkForChanges);
                }
            });
        }
        
        function setupFullscreenChangeTracking() {
            // Track fullscreen code changes
            if (fullscreenEditor) {
                fullscreenEditor.onDidChangeModelContent(() => {
                    checkForFullscreenChanges();
                });
            }
            
            // Track fullscreen form field changes
            const fields = ['fullscreen-editor-name', 'fullscreen-editor-address', 'fullscreen-editor-port', 'fullscreen-editor-protocol', 'fullscreen-editor-timeout'];
            fields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) {
                    field.addEventListener('input', checkForFullscreenChanges);
                    field.addEventListener('change', checkForFullscreenChanges);
                }
            });
        }
        
        function checkForChanges() {
            if (!monacoEditor) return;
            
            const currentCode = monacoEditor.getValue();
            const currentFormData = {
                name: document.getElementById('protocol-editor-name').value,
                address: document.getElementById('protocol-editor-address').value,
                port: document.getElementById('protocol-editor-port').value,
                protocol: document.getElementById('protocol-editor-protocol').value,
                timeout: document.getElementById('protocol-editor-timeout').value
            };
            
            const codeChanged = currentCode !== initialCode;
            const formChanged = JSON.stringify(currentFormData) !== JSON.stringify(initialFormData);
            
            protocolEditorSaveButton.disabled = !(codeChanged || formChanged);
        }
        
        function checkForFullscreenChanges() {
            if (!fullscreenEditor) return;
            
            const currentCode = fullscreenEditor.getValue();
            const currentFormData = {
                name: document.getElementById('fullscreen-editor-name').value,
                address: document.getElementById('fullscreen-editor-address').value,
                port: document.getElementById('fullscreen-editor-port').value,
                protocol: document.getElementById('fullscreen-editor-protocol').value,
                timeout: document.getElementById('fullscreen-editor-timeout').value
            };
            
            const codeChanged = currentCode !== initialFullscreenCode;
            const formChanged = JSON.stringify(currentFormData) !== JSON.stringify(initialFullscreenFormData);
            
            const fullscreenSaveBtn = document.getElementById('fullscreen-editor-save');
            if (fullscreenSaveBtn) {
                fullscreenSaveBtn.disabled = !(codeChanged || formChanged);
            }
        }

        // Fullscreen toggle button
        document.addEventListener('DOMContentLoaded', () => {
            const fullscreenToggleBtn = document.getElementById('fullscreen-toggle');
            if (fullscreenToggleBtn) {
                fullscreenToggleBtn.addEventListener('click', () => {
                    if (!isFullscreen) {
                        enterFullscreen();
                    } else {
                        exitFullscreen();
                    }
                });
            }

            // Exit fullscreen button
            const exitFullscreenBtn = document.getElementById('fullscreen-editor-close');
            if (exitFullscreenBtn) {
                exitFullscreenBtn.addEventListener('click', exitFullscreen);
            }


            // Fullscreen editor action handlers
            const fullscreenTestBtn = document.getElementById('fullscreen-editor-test');
            if (fullscreenTestBtn) {
                fullscreenTestBtn.addEventListener('click', async () => {
                    await runFullscreenTest();
                });
            }

            const fullscreenSaveBtn = document.getElementById('fullscreen-editor-save');
            if (fullscreenSaveBtn) {
                fullscreenSaveBtn.addEventListener('click', async () => {
                    await saveFullscreenGameServer();
                });
            }

            const fullscreenClearBtn = document.getElementById('fullscreen-editor-clear');
            if (fullscreenClearBtn) {
                fullscreenClearBtn.addEventListener('click', () => {
                    // Reset output to default state, but keep it visible
                    const outputContent = document.getElementById('fullscreen-output-content');
                    outputContent.innerHTML = `
                        <p class="editor-status">Status: Ready to test your script</p>
                        <pre style="max-height: 300px; overflow-y: auto;">Raw Response will appear here after preview</pre>
                        <div><p class="editor-subtitle">Variables</p>
                            <div class="var-parse-item">
                                <div class="var-parse-name">No variables</div>
                                <div class="var-parse-data">Variables from CODE blocks will appear here</div>
                            </div>
                        </div>
                        <div><p class="editor-subtitle">Parsed Values</p>
                            <div class="var-parse-item">
                                <div class="var-parse-name">No parsed values</div>
                                <div class="var-parse-data">Parsed values will appear here</div>
                            </div>
                        </div>
                        <p class="editor-subtitle">Response Time: --</p>
                        <div class="output-section"><p class="editor-subtitle">Output Success</p><div class="output-labels">Output labels will appear here once the test finishes.</div></div>
                        <div class="output-section"><p class="editor-subtitle">Output Error</p><div class="output-labels">Error labels will appear here if the test fails.</div></div>
                    `;
                });
            }
        });

        function enterFullscreen() {
            isFullscreen = true;
            const overlay = document.getElementById('fullscreen-editor-overlay');
            overlay.classList.add('active');
            
            // Copy values from regular editor to fullscreen editor
            if (monacoEditor && fullscreenEditor) {
                fullscreenEditor.setValue(monacoEditor.getValue());
            }
            
            // Sync form fields
            document.getElementById('fullscreen-editor-name').value = document.getElementById('protocol-editor-name').value;
            document.getElementById('fullscreen-editor-address').value = document.getElementById('protocol-editor-address').value;
            document.getElementById('fullscreen-editor-port').value = document.getElementById('protocol-editor-port').value;
            document.getElementById('fullscreen-editor-protocol').value = document.getElementById('protocol-editor-protocol').value;
            document.getElementById('fullscreen-editor-timeout').value = document.getElementById('protocol-editor-timeout').value;
            
            // Move output content to fullscreen output panel
            const outputSource = document.getElementById('protocol-editor-output');
            const outputDest = document.getElementById('fullscreen-output-content');
            outputDest.innerHTML = outputSource.innerHTML;
            
            // Initialize fullscreen initial state tracking
            initialFullscreenCode = fullscreenEditor ? fullscreenEditor.getValue() : '';
            initialFullscreenFormData = {
                name: document.getElementById('fullscreen-editor-name').value,
                address: document.getElementById('fullscreen-editor-address').value,
                port: document.getElementById('fullscreen-editor-port').value,
                protocol: document.getElementById('fullscreen-editor-protocol').value,
                timeout: document.getElementById('fullscreen-editor-timeout').value
            };
            
            // Setup change tracking if not already done
            if (fullscreenEditor) {
                setupFullscreenChangeTracking();
                // Initially disable save button (no changes yet)
                const fullscreenSaveBtn = document.getElementById('fullscreen-editor-save');
                if (fullscreenSaveBtn) {
                    fullscreenSaveBtn.disabled = true;
                }
                checkForFullscreenChanges();
            }
            
            // Layout fullscreen editor
            setTimeout(() => {
                if (fullscreenEditor) {
                    fullscreenEditor.layout();
                }
            }, 100);
        }

        function exitFullscreen() {
            isFullscreen = false;
            const overlay = document.getElementById('fullscreen-editor-overlay');
            overlay.classList.remove('active');
            
            // Copy values back from fullscreen editor to regular editor
            if (fullscreenEditor && monacoEditor) {
                monacoEditor.setValue(fullscreenEditor.getValue());
            }
            
            // Sync form fields back
            document.getElementById('protocol-editor-name').value = document.getElementById('fullscreen-editor-name').value;
            document.getElementById('protocol-editor-address').value = document.getElementById('fullscreen-editor-address').value;
            document.getElementById('protocol-editor-port').value = document.getElementById('fullscreen-editor-port').value;
            document.getElementById('protocol-editor-protocol').value = document.getElementById('fullscreen-editor-protocol').value;
            document.getElementById('protocol-editor-timeout').value = document.getElementById('fullscreen-editor-timeout').value;
            
            // Layout regular editor
            setTimeout(() => {
                if (monacoEditor) {
                    monacoEditor.layout();
                }
            }, 100);
        }

        async function runFullscreenTest() {
            if (isTestRunning) return;
            
            const name = document.getElementById('fullscreen-editor-name').value.trim() || 'Test Server';
            const address = document.getElementById('fullscreen-editor-address').value.trim();
            const port = parseInt(document.getElementById('fullscreen-editor-port').value, 10);
            const protocol = document.getElementById('fullscreen-editor-protocol').value;
            const timeoutMs = parseInt(document.getElementById('fullscreen-editor-timeout').value, 10) || 5000;
            const pseudoCode = fullscreenEditor ? fullscreenEditor.getValue() : '';

            if (!address) {
                alert('Server address required');
                return;
            }

            if (!(port > 0 && port <= 65535)) {
                alert('Port must be between 1 and 65535');
                return;
            }

            if (!pseudoCode) {
                alert('Pseudo-code is required');
                return;
            }

            // Disable test buttons
            isTestRunning = true;
            protocolEditorTestButton.disabled = true;
            const fullscreenTestBtn = document.getElementById('fullscreen-editor-test');
            if (fullscreenTestBtn) fullscreenTestBtn.disabled = true;

            try {
                const response = await fetch('/api/gameservers/test', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name,
                        address,
                        port,
                        protocol,
                        timeout_ms: timeoutMs,
                        pseudo_code: pseudoCode,
                    }),
                });

                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error?.message || result.error || 'Failed to run test');
                }

                // Update fullscreen output with results
                updateFullscreenOutput(result);
                
                // Also update regular output
                const status = result.success
                    ? '✅ Server response received'
                    : `❌ ${result.error?.message || 'Validation failed'}`;
                const parsed = formatParsedValues(result.parsed_values);
                const variables = result.variables || result.parsed_values || {};
                renderProtocolOutput({
                    status,
                    raw: result.raw_response ?? 'No response recorded',
                    parsed: parsed.length ? parsed : [],
                    variables: variables,
                    time: typeof result.response_time_ms === 'number' ? `${result.response_time_ms} ms` : '--',
                    outputLabelsSuccess: result.output_labels_success || [],
                    outputLabelsError: result.output_labels_error || [],
                });
            } catch (error) {
                alert(`Test failed: ${error.message}`);
            } finally {
                // Re-enable test buttons
                isTestRunning = false;
                protocolEditorTestButton.disabled = false;
                const fullscreenTestBtn = document.getElementById('fullscreen-editor-test');
                if (fullscreenTestBtn) fullscreenTestBtn.disabled = false;
            }
        }

        async function saveFullscreenGameServer() {
            const name = document.getElementById('fullscreen-editor-name').value.trim();
            const address = document.getElementById('fullscreen-editor-address').value.trim();
            const port = parseInt(document.getElementById('fullscreen-editor-port').value, 10);
            const protocol = document.getElementById('fullscreen-editor-protocol').value;
            const timeoutMs = parseInt(document.getElementById('fullscreen-editor-timeout').value, 10) || 5000;
            const pseudoCode = fullscreenEditor ? fullscreenEditor.getValue() : '';

            if (!name || !address || !(port > 0 && port <= 65535) || !pseudoCode) {
                alert('Please fill in all required fields');
                return;
            }

            try {
                const response = await fetch('/api/gameservers', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name,
                        address,
                        port,
                        protocol,
                        timeout_ms: timeoutMs,
                        pseudo_code: pseudoCode,
                    }),
                });

                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error || 'Failed to save game server');
                }

                alert(`Game server "${name}" saved successfully!`);
                
                // Update initial state after save (fullscreen)
                initialFullscreenCode = fullscreenEditor ? fullscreenEditor.getValue() : '';
                initialFullscreenFormData = {
                    name: document.getElementById('fullscreen-editor-name').value,
                    address: document.getElementById('fullscreen-editor-address').value,
                    port: document.getElementById('fullscreen-editor-port').value,
                    protocol: document.getElementById('fullscreen-editor-protocol').value,
                    timeout: document.getElementById('fullscreen-editor-timeout').value
                };
                checkForFullscreenChanges();
                
                // Also update regular editor state
                if (monacoEditor) {
                    initialCode = monacoEditor.getValue();
                    initialFormData = {
                        name: document.getElementById('protocol-editor-name').value,
                        address: document.getElementById('protocol-editor-address').value,
                        port: document.getElementById('protocol-editor-port').value,
                        protocol: document.getElementById('protocol-editor-protocol').value,
                        timeout: document.getElementById('protocol-editor-timeout').value
                    };
                    checkForChanges();
                }
                
                loadGameServers();
            } catch (error) {
                alert(`Failed to save game server: ${error.message}`);
            }
        }

        function updateFullscreenOutput(result) {
            const outputContent = document.getElementById('fullscreen-output-content');
            const status = result.success
                ? '✅ Server response received'
                : `❌ ${result.error?.message || 'Validation failed'}`;
            const parsed = formatParsedValues(result.parsed_values);
            const variables = result.variables || result.parsed_values || {};
            
            // Create output HTML similar to regular output
            let html = `<p class="editor-status">Status: ${status}</p>`;
            html += `<pre style="max-height: 300px; overflow-y: auto;">${escapeHtml(result.raw_response ?? 'No response recorded')}</pre>`;
            
            // Variables in new format
            html += '<div><p class="editor-subtitle">Variables</p>';
            if (Object.keys(variables).length === 0) {
                html += '<div class="var-parse-item"><div class="var-parse-name">No variables</div><div class="var-parse-data">Variables from CODE blocks will appear here</div></div>';
            } else {
                Object.entries(variables).forEach(([name, value]) => {
                    let displayValue = value;
                    if (typeof value === 'object') {
                        if (Array.isArray(value)) {
                            displayValue = `[${value.map(v => JSON.stringify(v)).join(', ')}]`;
                        } else {
                            displayValue = JSON.stringify(value);
                        }
                    } else if (typeof value === 'string') {
                        displayValue = `"${value}"`;
                    }
                    html += `<div class="var-parse-item"><div class="var-parse-name">${escapeHtml(String(name))}</div><div class="var-parse-data">${escapeHtml(String(displayValue))}</div></div>`;
                });
            }
            html += '</div>';
            
            // Parsed values in new format
            html += '<div><p class="editor-subtitle">Parsed Values</p>';
            if (parsed.length === 0) {
                html += '<div class="var-parse-item"><div class="var-parse-name">No parsed values</div><div class="var-parse-data">Parsed values will appear here</div></div>';
            } else {
                parsed.forEach(item => {
                    html += `<div class="var-parse-item"><div class="var-parse-name">${escapeHtml(item.name)}</div><div class="var-parse-data">${escapeHtml(String(item.value))}</div></div>`;
                });
            }
            html += '</div>';
            
            html += `<p class="editor-subtitle">Response Time: ${typeof result.response_time_ms === 'number' ? `${result.response_time_ms} ms` : '--'}</p>`;
            
            // Output labels
            html += '<div class="output-section"><p class="editor-subtitle">Output Success</p><div class="output-labels">';
            if (result.output_labels_success && result.output_labels_success.length > 0) {
                result.output_labels_success.forEach(label => {
                    html += `<div>${escapeHtml(label)}</div>`;
                });
            } else {
                html += 'Output labels will appear here once the test finishes.';
            }
            html += '</div></div>';
            
            html += '<div class="output-section"><p class="editor-subtitle">Output Error</p><div class="output-labels">';
            if (result.output_labels_error && result.output_labels_error.length > 0) {
                result.output_labels_error.forEach(label => {
                    html += `<div>${escapeHtml(label)}</div>`;
                });
            } else {
                html += 'Error labels will appear here if the test fails.';
            }
            html += '</div></div>';
            
            outputContent.innerHTML = html;
        }

        // Tab switching
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                const tabName = button.dataset.tab;
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                button.classList.add('active');
                document.getElementById(`${tabName}-tab`).classList.add('active');
                // Resize Monaco editor when tab becomes active
                if (tabName === 'protocol' && monacoEditor) {
                    setTimeout(() => monacoEditor.layout(), 100);
                }
            });
        });

        // Modal handling
        const deleteModal = document.getElementById('delete-modal');
        const deleteModalMessage = document.getElementById('delete-modal-message');
        const deleteModalCancel = document.getElementById('delete-modal-cancel');
        const deleteModalConfirm = document.getElementById('delete-modal-confirm');
        const deleteModalTitle = deleteModal.querySelector('h3');

        let deleteCallback = null;

        deleteModalCancel.addEventListener('click', () => {
            deleteModal.classList.remove('active');
            deleteCallback = null;
            // Reset modal to delete mode
            deleteModalTitle.textContent = 'Confirm Delete';
            deleteModalConfirm.textContent = 'Delete';
            deleteModalConfirm.className = 'delete';
        });

        deleteModalConfirm.addEventListener('click', () => {
            if (deleteCallback) {
                deleteCallback();
                deleteModal.classList.remove('active');
                deleteCallback = null;
                // Reset modal to delete mode
                deleteModalTitle.textContent = 'Confirm Delete';
                deleteModalConfirm.textContent = 'Delete';
                deleteModalConfirm.className = 'delete';
            }
        });

        function showDeleteModal(message, callback) {
            deleteModalTitle.textContent = 'Confirm Delete';
            deleteModalMessage.textContent = message;
            deleteModalConfirm.textContent = 'Delete';
            deleteModalConfirm.className = 'delete';
            deleteCallback = callback;
            deleteModal.classList.add('active');
        }

        function showSaveModal(message, callback) {
            deleteModalTitle.textContent = 'Confirm Save';
            deleteModalMessage.textContent = message;
            deleteModalConfirm.textContent = 'Save';
            deleteModalConfirm.className = 'test'; // Use test button style (green) for save
            deleteCallback = callback;
            deleteModal.classList.add('active');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ISP Management
        function showMessage(text, isError = false) {
            const messageEl = document.getElementById('message');
            messageEl.className = isError ? 'error' : 'success';
            messageEl.textContent = text;
            messageEl.style.display = 'block';
            setTimeout(() => {
                messageEl.style.display = 'none';
            }, 5000);
        }

        async function loadISPs() {
            try {
                const response = await fetch('/api/isps');
                if (!response.ok) throw new Error('Failed to fetch ISPs');
                const isps = await response.json();
                renderISPs(isps);
            } catch (error) {
                document.getElementById('isp-list').innerHTML = 
                    `<div class="error">Error loading ISPs: ${error.message}</div>`;
            }
        }

        function renderISPs(isps) {
            const listEl = document.getElementById('isp-list');
            if (isps.length === 0) {
                listEl.innerHTML = '<div class="empty-state">No ISPs configured. Add one above to get started.</div>';
                return;
            }

            listEl.innerHTML = isps.map(isp => `
                <div class="isp-item">
                    <div class="item-info">
                        <div class="item-name">${escapeHtml(isp.name)}</div>
                        <div class="item-details">${escapeHtml(isp.ip)}</div>
                    </div>
                    <div class="item-actions">
                        <button class="delete" onclick="deleteISP(${isp.id}, '${escapeHtml(isp.name)}')">Delete</button>
                    </div>
                </div>
            `).join('');
        }

        async function deleteISP(id, name) {
            showDeleteModal(`Are you sure you want to delete the ISP "${name}"? This action cannot be undone.`, async () => {
                try {
                    const response = await fetch(`/api/isps/${id}`, {
                        method: 'DELETE'
                    });
                    if (!response.ok) throw new Error('Failed to delete ISP');
                    showMessage('ISP deleted successfully');
                    loadISPs();
                } catch (error) {
                    showMessage(`Error deleting ISP: ${error.message}`, true);
                }
            });
        }
        window.deleteISP = deleteISP;

        document.getElementById('isp-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const formData = new FormData(e.target);
            const data = {
                name: formData.get('name'),
                ip: formData.get('ip')
            };

            try {
                const response = await fetch('/api/isps', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                });

                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error || 'Failed to create ISP');
                }

                showMessage('ISP added successfully');
                e.target.reset();
                loadISPs();
            } catch (error) {
                showMessage(`Error adding ISP: ${error.message}`, true);
            }
        });

        // Website Management
        const directConnectCheckbox = document.getElementById('website-direct-connect');
        const directUrlGroup = document.getElementById('direct-url-group');

        directConnectCheckbox.addEventListener('change', function() {
            directUrlGroup.style.display = this.checked ? 'block' : 'none';
        });

        async function loadWebsites() {
            try {
                const response = await fetch('/api/websites');
                if (!response.ok) throw new Error('Failed to fetch websites');
                const websites = await response.json();
                renderWebsites(websites);
            } catch (error) {
                document.getElementById('website-list').innerHTML = 
                    `<div class="error">Error loading websites: ${error.message}</div>`;
            }
        }

        function renderWebsites(websites) {
            const listEl = document.getElementById('website-list');
            if (websites.length === 0) {
                listEl.innerHTML = '<div class="empty-state">No websites configured. Add one above to get started.</div>';
                return;
            }

            listEl.innerHTML = websites.map(website => `
                <div class="website-item">
                    <div class="item-info">
                        <div class="item-name">${escapeHtml(website.url)}</div>
                        <div class="item-details">
                            Direct Connect: ${website.direct_connect ? 'Yes' : 'No'}
                            ${website.direct_connect_url ? ` | Direct URL: ${escapeHtml(website.direct_connect_url)}` : ''}
                        </div>
                    </div>
                    <div class="item-actions">
                        <button class="delete" onclick="deleteWebsite(${website.id}, '${escapeHtml(website.url)}')">Delete</button>
                    </div>
                </div>
            `).join('');
        }

        async function deleteWebsite(id, url) {
            showDeleteModal(`Are you sure you want to delete the website "${url}"? This action cannot be undone.`, async () => {
                try {
                    const response = await fetch(`/api/websites/${id}`, {
                        method: 'DELETE'
                    });
                    if (!response.ok) throw new Error('Failed to delete website');
                    showWebsiteMessage('Website deleted successfully');
                    loadWebsites();
                } catch (error) {
                    showWebsiteMessage(`Error deleting website: ${error.message}`, true);
                }
            });
        }
        window.deleteWebsite = deleteWebsite;

        function showWebsiteMessage(text, isError = false) {
            const messageEl = document.getElementById('website-message');
            messageEl.className = isError ? 'error' : 'success';
            messageEl.textContent = text;
            messageEl.style.display = 'block';
            setTimeout(() => {
                messageEl.style.display = 'none';
            }, 5000);
        }

        document.getElementById('website-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const formData = new FormData(e.target);
            const directUrlValue = formData.get('direct_connect_url');
            const data = {
                url: formData.get('url'),
                direct_connect: directConnectCheckbox.checked,
                direct_connect_url: directConnectCheckbox.checked && directUrlValue && directUrlValue.trim() !== '' ? directUrlValue.trim() : null
            };

            try {
                const response = await fetch('/api/websites', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                });

                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error || 'Failed to create website');
                }

                showWebsiteMessage('Website added successfully');
                e.target.reset();
                directUrlGroup.style.display = 'none';
                loadWebsites();
            } catch (error) {
                showWebsiteMessage(`Error adding website: ${error.message}`, true);
            }
        });

        // Game Server Management
        async function loadGameServers() {
            try {
                const response = await fetch('/api/gameservers');
                if (!response.ok) throw new Error('Failed to fetch game servers');
                const servers = await response.json();
                renderGameServers(servers);
            } catch (error) {
                document.getElementById('gameserver-list').innerHTML = 
                    `<div class="error">Error loading game servers: ${error.message}</div>`;
            }
        }

        function renderGameServers(servers) {
            const listEl = document.getElementById('gameserver-list');
            if (servers.length === 0) {
                listEl.innerHTML = '<div class="empty-state">No game servers configured. Create one in the Protocol-Agnostic tab to get started.</div>';
                return;
            }

            listEl.innerHTML = servers.map(server => `
                <div class="gameserver-item">
                    <div class="item-info">
                        <div class="item-name">${escapeHtml(server.name)}</div>
                        <div class="gameserver-details">
                            <span><strong>Address:</strong> ${escapeHtml(server.address)}</span>
                            <span><strong>Port:</strong> ${server.port}</span>
                            <span><strong>Protocol:</strong> ${server.protocol}</span>
                            <span><strong>Timeout:</strong> ${server.timeout_ms}ms</span>
                        </div>
                    </div>
                    <div class="item-actions">
                        <button class="edit" onclick="editGameServer(${server.id})">Edit</button>
                        <button class="test" onclick="testGameServer(${server.id})">Test</button>
                        <button class="delete" onclick="deleteGameServer(${server.id}, '${escapeHtml(server.name)}')">Delete</button>
                    </div>
                </div>
            `).join('');
        }

        async function deleteGameServer(id, name) {
            showDeleteModal(`Are you sure you want to delete the game server "${name}"? This action cannot be undone.`, async () => {
                try {
                    const response = await fetch(`/api/gameservers/${id}`, {
                        method: 'DELETE'
                    });
                    if (!response.ok) throw new Error('Failed to delete game server');
                    loadGameServers();
                } catch (error) {
                    alert(`Error deleting game server: ${error.message}`);
                }
            });
        }
        window.deleteGameServer = deleteGameServer;

        async function editGameServer(id) {
            try {
                const response = await fetch('/api/gameservers');
                if (!response.ok) throw new Error('Failed to fetch game servers');
                const servers = await response.json();
                const server = servers.find(s => s.id === id);
                if (!server) {
                    alert('Game server not found');
                    return;
                }

                // Populate protocol editor fields
                document.getElementById('protocol-editor-name').value = server.name;
                document.getElementById('protocol-editor-address').value = server.address;
                document.getElementById('protocol-editor-port').value = server.port;
                document.getElementById('protocol-editor-protocol').value = server.protocol;
                document.getElementById('protocol-editor-timeout').value = server.timeout_ms;
                
                // Set Monaco editor content
                if (monacoEditor) {
                    monacoEditor.setValue(server.pseudo_code);
                }

                // Store the ID for updating (if we had an update endpoint)
                protocolEditorSaveButton.dataset.serverId = id;

                // Switch to Protocol-Agnostic tab
                document.querySelector('[data-tab="protocol"]').click();
                setTimeout(() => {
                    if (monacoEditor) {
                        monacoEditor.layout();
                    }
                }, 100);
            } catch (error) {
                alert(`Error loading game server: ${error.message}`);
            }
        }
        window.editGameServer = editGameServer;

        async function testGameServer(id) {
            try {
                const response = await fetch(`/api/gameservers/${id}/test`, {
                    method: 'POST'
                });

                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error?.message || result.error || 'Failed to test game server');
                }

                const status = result.success
                    ? '✅ Server response received'
                    : `❌ ${result.error?.message || 'Validation failed'}`;
                const parsed = formatParsedValues(result.parsed_values);
                const variables = result.variables || result.parsed_values || {};
                
                renderProtocolOutput({
                    status,
                    raw: result.raw_response ?? 'No response recorded',
                    parsed: parsed.length ? parsed : [],
                    variables: variables,
                    time: typeof result.response_time_ms === 'number' ? `${result.response_time_ms} ms` : '--',
                    outputLabelsSuccess: result.output_labels_success || [],
                    outputLabelsError: result.output_labels_error || [],
                });

                const successType = result.success ? 'success' : 'error';
                appendProtocolLog(`Test result: ${status}`, successType);
                
                // Switch to protocol tab to show results
                document.querySelector('[data-tab="protocol"]').click();
            } catch (error) {
                appendProtocolLog(`Test failed: ${error.message}`, 'error');
                renderProtocolOutput({
                    status: `Error: ${error.message}`,
                    raw: 'No response recorded',
                    parsed: [],
                    variables: {},
                    time: '--',
                    outputLabelsSuccess: [],
                    outputLabelsError: [],
                });
                document.querySelector('[data-tab="protocol"]').click();
            }
        }
        window.testGameServer = testGameServer;

        // Protocol Editor functions
        function formatParsedValues(value) {
            if (value && typeof value === 'object' && !Array.isArray(value)) {
                const entries = Object.entries(value);
                if (entries.length > 0) {
                    return entries.map(([name, val]) => ({
                        name,
                        value: typeof val === 'object' ? JSON.stringify(val) : String(val),
                    }));
                }
            }
            if (value !== undefined && value !== null) {
                return [{ name: 'value', value: JSON.stringify(value) }];
            }
            return [];
        }

        function renderSection(container, labels, emptyText) {
            if (!container) return;
            if (labels.length === 0) {
                container.textContent = emptyText;
            } else {
                container.innerHTML = labels.map(label => `<div>${escapeHtml(label)}</div>`).join('');
            }
        }
        const protocolEditorStatus = document.getElementById('protocol-editor-status');
        const protocolEditorRaw = document.getElementById('protocol-editor-raw');
        const protocolEditorVariables = document.getElementById('protocol-editor-variables');
        const protocolEditorParsed = document.getElementById('protocol-editor-parsed');
        const protocolEditorResponseTime = document.getElementById('protocol-editor-response-time');
        const protocolEditorOutputSuccess = document.getElementById('protocol-editor-output-success');
        const protocolEditorOutputError = document.getElementById('protocol-editor-output-error');
        const protocolEditorTestButton = document.getElementById('protocol-editor-test');
        const protocolEditorSaveButton = document.getElementById('protocol-editor-save');
        const protocolEditorClearButton = document.getElementById('protocol-editor-clear');
        const protocolEditorLog = document.getElementById('protocol-editor-log');

        function appendProtocolLog(message, type = 'info') {
            if (protocolEditorLog.children.length === 1 && protocolEditorLog.children[0].textContent.includes('Logs will appear here')) {
                protocolEditorLog.innerHTML = '';
            }
            const entry = document.createElement('div');
            entry.className = `log-entry${type !== 'info' ? ' ' + type : ''}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            protocolEditorLog.appendChild(entry);
            protocolEditorLog.scrollTop = protocolEditorLog.scrollHeight;
        }

        function renderProtocolVariables(variables) {
            if (!variables || Object.keys(variables).length === 0) {
                protocolEditorVariables.innerHTML = `
                    <div class="var-parse-item">
                        <div class="var-parse-name">No variables</div>
                        <div class="var-parse-data">Variables from CODE blocks will appear here</div>
                    </div>
                `;
                return;
            }
            const items = Object.entries(variables)
                .map(([name, value]) => {
                    let displayValue = value;
                    if (typeof value === 'object') {
                        if (Array.isArray(value)) {
                            displayValue = `[${value.map(v => JSON.stringify(v)).join(', ')}]`;
                        } else {
                            displayValue = JSON.stringify(value);
                        }
                    } else if (typeof value === 'string') {
                        displayValue = `"${value}"`;
                    }
                    return `
                        <div class="var-parse-item">
                            <div class="var-parse-name">${escapeHtml(String(name))}</div>
                            <div class="var-parse-data">${escapeHtml(String(displayValue))}</div>
                        </div>
                    `;
                })
                .join('');
            protocolEditorVariables.innerHTML = items;
        }
        
        function addNewVariable() {
            // Placeholder for adding new variables
            console.log('Add new variable clicked');
        }
        window.addNewVariable = addNewVariable;

        function renderProtocolParsed(values) {
            if (!values || values.length === 0) {
                protocolEditorParsed.innerHTML = `
                    <div class="var-parse-item">
                        <div class="var-parse-name">No parsed values</div>
                        <div class="var-parse-data">Parsed values will appear here</div>
                    </div>
                `;
                return;
            }
            const items = values
                .map((item) => `
                    <div class="var-parse-item">
                        <div class="var-parse-name">${escapeHtml(item.name)}</div>
                        <div class="var-parse-data">${escapeHtml(String(item.value))}</div>
                    </div>
                `)
                .join('');
            protocolEditorParsed.innerHTML = items;
        }
        
        function addNewParsed() {
            // Placeholder for adding new parsed values
            console.log('Add new parsed clicked');
        }
        window.addNewParsed = addNewParsed;

        function renderProtocolOutput({ status, raw, parsed, variables, time, outputLabelsSuccess, outputLabelsError }) {
            protocolEditorStatus.textContent = `Status: ${status}`;
            protocolEditorRaw.textContent = raw;
            protocolEditorResponseTime.textContent = `Response Time: ${time}`;
            renderProtocolVariables(variables || {});
            renderProtocolParsed(parsed);
            renderProtocolOutputSections(outputLabelsSuccess || [], outputLabelsError || []);
        }

        function renderProtocolOutputSections(successLabels, errorLabels) {
            renderSection(protocolEditorOutputSuccess, successLabels, 'Output labels will appear here once the test finishes.');
            renderSection(protocolEditorOutputError, errorLabels, 'Error labels will appear here if the test fails.');
        }

        protocolEditorTestButton.addEventListener('click', async () => {
            const name = document.getElementById('protocol-editor-name').value.trim() || 'Test Server';
            const address = document.getElementById('protocol-editor-address').value.trim();
            const port = parseInt(document.getElementById('protocol-editor-port').value, 10);
            const protocol = document.getElementById('protocol-editor-protocol').value;
            const timeoutMs = parseInt(document.getElementById('protocol-editor-timeout').value, 10) || 5000;
            const pseudoCode = monacoEditor ? monacoEditor.getValue() : '';

            if (!address) {
                appendProtocolLog('Validation error: Server address required.', 'error');
                renderProtocolOutput({
                    status: 'Error: Server address required',
                    raw: 'No response recorded',
                    parsed: [],
                    variables: {},
                    time: '--',
                    outputLabelsSuccess: [],
                    outputLabelsError: [],
                });
                return;
            }

            if (!(port > 0 && port <= 65535)) {
                appendProtocolLog('Validation error: Port must be between 1 and 65535.', 'error');
                renderProtocolOutput({
                    status: 'Error: Provide a valid port (1-65535)',
                    raw: 'No response recorded',
                    parsed: [],
                    variables: {},
                    time: '--',
                    outputLabelsSuccess: [],
                    outputLabelsError: [],
                });
                return;
            }

            if (!pseudoCode) {
                appendProtocolLog('Validation error: Pseudo-code is required.', 'error');
                renderProtocolOutput({
                    status: 'Error: Pseudo-code is required for testing',
                    raw: 'No response recorded',
                    parsed: [],
                    variables: {},
                    time: '--',
                    outputLabelsSuccess: [],
                    outputLabelsError: [],
                });
                return;
            }

            renderProtocolOutput({
                status: 'Running test...',
                raw: 'Waiting for response...',
                parsed: [],
                variables: {},
                time: '--',
                outputLabelsSuccess: [],
                outputLabelsError: [],
            });
            appendProtocolLog(`Starting test for ${address}:${port}`);
            appendProtocolLog(`Pseudo-code payload:\n${pseudoCode}`);

            try {
                const response = await fetch('/api/gameservers/test', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name,
                        address,
                        port,
                        protocol,
                        timeout_ms: timeoutMs,
                        pseudo_code: pseudoCode,
                    }),
                });

                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error?.message || result.error || 'Failed to run test');
                }

                const status = result.success
                    ? '✅ Server response received'
                    : `❌ ${result.error?.message || 'Validation failed'}`;
                const parsed = formatParsedValues(result.parsed_values);
                const variables = result.variables || result.parsed_values || {};
                renderProtocolOutput({
                    status,
                    raw: result.raw_response ?? 'No response recorded',
                    parsed: parsed.length ? parsed : [],
                    variables: variables,
                    time: typeof result.response_time_ms === 'number' ? `${result.response_time_ms} ms` : '--',
                    outputLabelsSuccess: result.output_labels_success || [],
                    outputLabelsError: result.output_labels_error || [],
                });
                const successType = result.success ? 'success' : 'error';
                appendProtocolLog(`Test result: ${status}`, successType);
            } catch (error) {
                renderProtocolOutput({
                    status: `Error: ${error.message}`,
                    raw: 'No response recorded',
                    parsed: [],
                    variables: {},
                    time: '--',
                    outputLabelsSuccess: [],
                    outputLabelsError: [],
                });
                appendProtocolLog(`Test failed: ${error.message}`, 'error');
            } finally {
                // Re-enable test buttons
                isTestRunning = false;
                protocolEditorTestButton.disabled = false;
                if (fullscreenTestBtn) fullscreenTestBtn.disabled = false;
            }
        });

        protocolEditorSaveButton.addEventListener('click', async () => {
            const name = document.getElementById('protocol-editor-name').value.trim();
            const address = document.getElementById('protocol-editor-address').value.trim();
            const port = parseInt(document.getElementById('protocol-editor-port').value, 10);
            const protocol = document.getElementById('protocol-editor-protocol').value;
            const timeoutMs = parseInt(document.getElementById('protocol-editor-timeout').value, 10) || 5000;
            const pseudoCode = monacoEditor ? monacoEditor.getValue() : '';
            const serverId = protocolEditorSaveButton.dataset.serverId;

            if (!name) {
                appendProtocolLog('Validation error: Server name is required.', 'error');
                return;
            }

            if (!address) {
                appendProtocolLog('Validation error: Server address is required.', 'error');
                return;
            }

            if (!(port > 0 && port <= 65535)) {
                appendProtocolLog('Validation error: Port must be between 1 and 65535.', 'error');
                return;
            }

            if (!pseudoCode) {
                appendProtocolLog('Validation error: Pseudo-code is required.', 'error');
                return;
            }

            // If there's a serverId, we're editing an existing server - show confirmation
            if (serverId) {
                showSaveModal(`Are you sure you want to save changes to the game server "${name}"? This will overwrite the existing entry.`, async () => {
                    await performSave(name, address, port, protocol, timeoutMs, pseudoCode);
                });
            } else {
                // New server, save directly
                await performSave(name, address, port, protocol, timeoutMs, pseudoCode);
            }
        });

        async function performSave(name, address, port, protocol, timeoutMs, pseudoCode) {
            appendProtocolLog(`Saving game server: ${name}`);

            try {
                const response = await fetch('/api/gameservers', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name,
                        address,
                        port,
                        protocol,
                        timeout_ms: timeoutMs,
                        pseudo_code: pseudoCode,
                    }),
                });

                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error || 'Failed to save game server');
                }

                appendProtocolLog(`Game server "${name}" saved successfully!`, 'success');
                protocolEditorSaveButton.removeAttribute('data-server-id');
                
                // Update initial state after save
                initialCode = monacoEditor ? monacoEditor.getValue() : '';
                initialFormData = {
                    name: document.getElementById('protocol-editor-name').value,
                    address: document.getElementById('protocol-editor-address').value,
                    port: document.getElementById('protocol-editor-port').value,
                    protocol: document.getElementById('protocol-editor-protocol').value,
                    timeout: document.getElementById('protocol-editor-timeout').value
                };
                checkForChanges();
                
                loadGameServers();
            } catch (error) {
                appendProtocolLog(`Failed to save game server: ${error.message}`, 'error');
            }
        }

        protocolEditorClearButton.addEventListener('click', () => {
            // Clear the log
            protocolEditorLog.innerHTML = '<div class="log-entry">Logs will appear here when a test runs.</div>';
            // Clear only the output side
            renderProtocolOutput({
                status: 'Ready to test your script',
                raw: 'Raw Response will appear here after preview',
                parsed: [],
                variables: {},
                time: '--',
                outputLabelsSuccess: [],
                outputLabelsError: [],
            });
        });

        // Initialize
        loadISPs();
        loadWebsites();
        loadGameServers();
    </script>
</body>
</html>
